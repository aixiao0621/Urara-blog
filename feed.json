{"version":"https://jsonfeed.org/version/1.1","title":"Az's Blog","home_page_url":"https://az0x01-blog.vercel.app","feed_url":"https://az0x01-blog.vercel.app/feed.json","description":"hello👋","icon":"https://az0x01-blog.vercel.app/assets/any@512.png","favicon":"https://az0x01-blog.vercel.app/favicon.png","authors":[{"name":"Az","url":"https://az0x01-blog.vercel.app","avatar":"/assets/maskable@512.png"}],"language":"en-US","items":[{"id":"20230805","url":"https://az0x01-blog.vercel.app/20230805","title":"LVGL 初探","content_html":"<h2 id=\"环境需求\"><a href=\"#环境需求\">环境需求</a></h2><ul><li>ESP32-S3-LCD-EV-BOARD</li><li><a href=\"https://squareline.io/\" rel=\"nofollow noopener noreferrer external\" target=\"_blank\">SquareLine Stdio</a> v1.3.1</li><li>ESP-IDF v5.0.2</li></ul><h2 id=\"创建项目\"><a href=\"#创建项目\">创建项目</a></h2><ol><li>在 SquareLine Stdio 的欢迎菜单中选择 Example，选择任意一个示例项目，点击 creat，待相关文件加载完毕</li><li>打开 flie 选项卡的 Project setting 修改 BOARD GROUP 为 Espressif，选择 开发板型号并保存</li><li>在 Font Manager 选项卡的 CREATFONT 下进行 modify 以防报错</li><li>在 Inspector 选项卡的 STYLE(MAIN) 下 确定项目的 Text Font，以便稍后修改</li><li>在 Export 选项卡中导出项目，先 Creat Template project 然后再 Export UI Files</li></ol><h2 id=\"修改-menuconfig\"><a href=\"#修改-menuconfig\">修改 Menuconfig</a></h2><h3 id=\"修改字体\"><a href=\"#修改字体\">修改字体</a></h3><p>在 ESP-IDF 中打开项目 使用 <code>idf.py menuconfig</code> 命令<br>搜索 <code>font 26</code> 选择 LV_FONTMONTSERRAT_26(=n) “Enable Montserrat 26” 启用后保存</p><h3 id=\"设置-psram-为-120mhz\"><a href=\"#设置-psram-为-120mhz\">设置 psram 为 120MHz</a></h3><!-- HTML_TAG_START --><pre class=\"shiki material-default\" md=\"true\"><div class=\"language-id\">md</div><div class='code-container'><code><div class='line'>1. 搜索 psram</div><div class='line'>2. 选择 SPIRAM_MODE_OCT(=y) \"Octal Mode PSRAM\"</div><div class='line'>3. 进入 Octal Mode PSRAM</div><div class='line'>4. 进入 Set RAM clock speed</div><div class='line'>5. 选择 120MHz clock speed</div></code></div></pre><!-- HTML_TAG_END --><h3 id=\"设置-flash-为-120mhz\"><a href=\"#设置-flash-为-120mhz\">设置 flash 为 120MHz</a></h3><!-- HTML_TAG_START --><pre class=\"shiki material-default\" md=\"true\"><div class=\"language-id\">md</div><div class='code-container'><code><div class='line'>1. 搜索 flash</div><div class='line'>2. 选择 ESPTOOLPY_FLASHFREQ_120M(=n) \"120MHz\"</div><div class='line'>3. 选择 120MHz</div></code></div></pre><!-- HTML_TAG_END --><h3 id=\"设置-data-cache-line\"><a href=\"#设置-data-cache-line\">设置 data cache line</a></h3><!-- HTML_TAG_START --><pre class=\"shiki material-default\" md=\"true\"><div class=\"language-id\">md</div><div class='code-container'><code><div class='line'>1. 搜索 data cache line</div><div class='line'>2. 选择 ESP_32S3_DATA_CACHE_LINE_64B(=n) \"64 Bytes\"</div><div class='line'>3. 选择 64Bytes</div></code></div></pre><!-- HTML_TAG_END --><h3 id=\"开启防撕裂模式\"><a href=\"#开启防撕裂模式\">开启防撕裂模式</a></h3><!-- HTML_TAG_START --><pre class=\"shiki material-default\" md=\"true\"><div class=\"language-id\">md</div><div class='code-container'><code><div class='line'>1. 搜索 avoid tearing effect</div><div class='line'>2. 进入 BSP_DISPLAY_LVGL_AVOID_TEAR(=n) \"Avoid tearing effect\"</div><div class='line'>3. 选择 Avoid tearing effect (NEW),进入 LCD</div><div class='line'>4. 开启 Enable to use double frame buffers 以及 Enable to refresh LCD manually</div><div class='line'>5. 进入 Display， 开启 Avoid tearing effect</div><div class='line'>6. 进入 Select LVGL buffer mode，开启 Direct mode</div></code></div></pre><!-- HTML_TAG_END --><h2 id=\"编译烧录\"><a href=\"#编译烧录\">编译烧录</a></h2><p>在 ESP-IDF 中使用 <code>idf.py build</code> 编译后进行烧录</p>","summary":"使用 SquareLine Stdio 的 GUI 开发","image":"","date_published":"2023-08-05T00:00:00.000Z","date_modified":"2023-08-05T00:00:00.000Z","tags":["IoT"],"_indieweb":{"type":"article"}},{"id":"page4","url":"https://az0x01-blog.vercel.app/page4","title":"小天同学 第三方 APP 开发","content_html":"<p>官方 APP 使用不便 想开发一个使用更加便捷的第三方 APP</p><h2 id=\"app-方向\"><a href=\"#app-方向\">APP 方向</a></h2><p>抓包 发现 <code>data</code> 有加密 尝试解密失败，试图寻找源码使用工具<a href=\"https://github.com/hluwa/frida-dexdump\" rel=\"nofollow noopener noreferrer external\" target=\"_blank\">frida-dexdump</a> 脱壳，但得到的代码可读性很低，发现有小程序，于是转战</p><h2 id=\"微信小程序方向\"><a href=\"#微信小程序方向\">微信小程序方向</a></h2><blockquote><p>原以为小程序和微信服务器的沟通只是为了拿到手机号明文，于是想要直接使用小程序的请求方式完成登录等全部流程</p></blockquote><ul><li>使用工具 <a href=\"https://github.com/r3x5ur/unveilr\" rel=\"nofollow noopener noreferrer external\" target=\"_blank\">unveilr</a> 直接对<code>__APP__.wxapkg</code>进行解包</li><li>使用<code>微信开发者工具</code>打开解包后的文件并尝试编译，成功 (好运)</li><li>尝试使用 Burpsuite 和 proxifier 对 PC 端小程序抓包，参考了<a href=\"https://blog.csdn.net/weixin_45031612/article/details/127416319\" rel=\"nofollow noopener noreferrer external\" target=\"_blank\">相关教程</a>,寻找登录请求，发现和 APP 抓到的包有相同的加密</li><li>由于解包后的小程序代码有混淆，可读性差，于是直接调试</li><li>小程序的主要 JS 代码位于根目录下，由于其中的函数均声明了 <code>&quot;use strict&quot;</code> 所以先删除</li><li>搜索加密函数 直接使用<code>console.log</code>打印，在调试器里导出为全局变量 就可以进行加解密操作了</li><li>在某些情况下，会提示字符串不是 UTF-8，这时候需要将 <code>\\\\/</code> 改为 <code>\\/</code> 可能还需要增减 <code>=</code> 的数量</li><li>到这里以为已经结束了，抓到的包可以直接解出，但是解密小程序的登录请求后发现里面还有一层加密且无法使用同样的解密方式解密</li><li>解密的微信小程序登录请求包中存在一个名为<code>code</code>的 key 通过查阅微信开发者文档，判断应该是与微信服务器的交流中拿到的，奈何微信的数据包加密十分抽象，没有思路拿到 <code>code</code> 于是思路再次中断</li></ul><h2 id=\"又回到最初的起点\"><a href=\"#又回到最初的起点\">又回到最初的起点🎵</a></h2><ul><li>偶然发现小程序的解密方式对 APP 抓到的包同样适用，于是柳暗花明，拿到验证码登录和打开饮水机的请求方式</li><li>现在只需要复现加解密函数即可，找到 <code>crypto-js</code> 库，发现完全一致，仅需的两个参数：密钥和密钥偏移量，也写在小程序的源码中</li></ul><blockquote><p>上面提到的<code>code</code>应该是微信服务端同时发送到小程序服务端和小程序客户端，一起发送给小程序服务端的还有被加密的手机号，小程序客户端需要用<code>code</code>才能拿到明文手机号</p></blockquote><h2 id=\"app-开发\"><a href=\"#app-开发\">APP 开发</a></h2><ul><li>在伪造请求时要注意发送数据的编码类型</li><li>在新版本中，如果要发送 http 请求，需要在 <code>AndroidManifest.xml</code> 的 <code>application</code> 中 增加 <code>android:usesCleartextTraffic=&quot;true&quot;</code></li><li>可能是由于编码方式的问题 返回的字符串有多余的 <code>\\&quot;</code> 和 <code>\\\\</code> 字符</li><li>在 kotlin 中进行解密操作时，由于 <code>\\\\/</code> 字符的出现，需要使用三层`<code>对整体字符串进行包裹，使其转为 </code>raw` 后再进行替换操作</li><li>替换字符串时，kotlin 的正则貌似不大好用</li></ul>","image":"/page4/logo.svg","date_published":"2023-05-10T00:00:00.000Z","date_modified":"2023-05-15T00:00:00.000Z","tags":["Android","Rev"],"_indieweb":{"type":"article"}},{"id":"page2","url":"https://az0x01-blog.vercel.app/page2","title":"使用 frida 对 APP 进行脱壳","content_html":"<h2 id=\"android-端的准备\"><a href=\"#android-端的准备\">Android 端的准备</a></h2><ol><li>在 <a href=\"https://github.com/frida/frida\" rel=\"nofollow noopener noreferrer external\" target=\"_blank\">frida</a> 仓库中下载<code>frida-server</code>文件，需要与手机架构和 PC 端 frida 版本相对应，解压后可以使用<code>adb push</code> 到手机，也可以使用 <code>MT文件管理器</code>，将其移动到 <code>/data/local/tmp</code> 目录内，赋予 <code>777</code> 权限</li><li>将手机与电脑连接，使用 <code>adb devices</code> 查看连接的设备，确保 adb 正确连接</li></ol><h2 id=\"pc-端的准备\"><a href=\"#pc-端的准备\">PC 端的准备</a></h2><ol><li>使用 <code>pip install frida</code> 命令安装 <a href=\"https://github.com/frida/frida\" rel=\"nofollow noopener noreferrer external\" target=\"_blank\">frida</a></li><li>使用 <code>pip install frida-tools</code> 命令安装 frida-tools  </li><li>使用<code>pip3 install frida-dexdump</code> 安装 <a href=\"https://github.com/hluwa/FRIDA-DEXDump\" rel=\"nofollow noopener noreferrer external\" target=\"_blank\">dexdump</a></li><li>在 cmd 中执行以下命令  </li></ol><!-- HTML_TAG_START --><pre class=\"shiki material-default\" shell=\"true\"><div class=\"language-id\">shell</div><div class='code-container'><code><div class='line'>adb shell  </div><div class='line'>cd /data/local/tmp/  </div><div class='line'>su  </div><div class='line'>./frida-server-android...  </div></code></div></pre><!-- HTML_TAG_END --><h2 id=\"开始脱壳\"><a href=\"#开始脱壳\">开始脱壳</a></h2><ol><li>打开新的 cmd 执行以下命令 <code>frida-dexdump -U -f com.app.pkgname</code> 即可开始脱壳  </li><li>推荐加上 <code>-d</code> 即深度搜索，结果更加完整，注意 <code>-f</code> 后必须直接跟包名</li></ol><h2 id=\"修复和查看\"><a href=\"#修复和查看\">修复和查看</a></h2><ol><li>生成的项目文件存放在<code>C:\\\\Windows\\\\System32</code>目录下  </li><li>使用 MT 管理器进行 dex 修复  </li><li>使用 jadx 查看修复后的 dex 文件  </li></ol>","image":"/page2/frida.png","date_published":"2023-04-01T00:00:00.000Z","date_modified":"2023-04-01T00:00:00.000Z","tags":["frida","Rev"],"_indieweb":{"type":"article"}},{"id":"page3","url":"https://az0x01-blog.vercel.app/page3","title":" 为 J1900 小主机刷写 openWRT","content_html":"<h2 id=\"刷写\"><a href=\"#刷写\">刷写</a></h2><ol><li>准备 PE 盘：复制准备好的 openwrt 镜像 (x86-64)，（为了方便这里选择了整合包）和刷写工具 <a href=\"https://m0n0.ch/wall/physdiskwrite.php\" rel=\"nofollow noopener noreferrer external\" target=\"_blank\">physdiskwrite</a> 到 PE 盘  </li><li>刷写镜像：在 bios 修改启动项，进入 PE，将原磁盘格式化为一个分区，使用 <code>physdiskwrite</code> 命令刷写，在 cmd 中输入命令 <code>.\\physdiskwriter.exe -u &lt;镜像路径&gt;</code> 进行刷写</li><li>启动：修改回原来的启动项再启动，就可以进入 <code>openWRT</code></li></ol><h2 id=\"其他\"><a href=\"#其他\">其他</a></h2><ul><li>整合包中自带了 <code>openclash</code> ，导入配置即可使用，如果安装 <code>docker</code>，则需要使用 <code>TUN模式</code></li><li>在 BIOS 中设置通电自启是必要的  </li><li>在使用工具刷写时，需要选择要刷写的盘，请确定<code>0</code>和<code>1</code>中哪个才是硬盘，确定不了就多试几次吧 (悲)  </li><li>下载下来的镜像可能需要多次解压，需要的是分为<code>0.img ...</code>的上一级  </li><li>进入 PE 的方法请自行百度，台式机大多为开机时按 ESC 在 <code>BIOS</code> 中的 <code>BOOT</code> 选项中更改启动项，将 PE 盘放在第一位，保存并重启  </li><li>openWRT 初次启动后请设置账户密码  </li><li>服务长时间不重新启动可能会造成网速过慢</li></ul>","summary":"尽管并不稳定，但折腾就对了","date_published":"2023-03-05T00:00:00.000Z","date_modified":"2023-03-18T00:00:00.000Z","tags":["IoT"],"_indieweb":{"type":"article"}},{"id":"page1","url":"https://az0x01-blog.vercel.app/page1","title":"通过 Homeassistant 控制继电器","content_html":"<h2 id=\"环境安装\"><a href=\"#环境安装\">环境安装</a></h2><ol><li>使用<a href=\"https://github.com/AlexxIT/HassWP\" rel=\"nofollow noopener noreferrer external\" target=\"_blank\">HassWP</a>作为 homeassistant 客户端。</li><li>使用 ESPHome 作为连接 ESP8266 与 HA 的平台，由于 HassWP 并不是 HA 的完全体，所以这里需要安装完整的 ESPHome，这里选择将其部署在 Liunx 虚拟机上。</li><li>在安装 ESPHome 前请确保 Liunx 的 python 处于较高版本，这里使用了 3.11.1 版本。</li><li>使用 <code>pip3 install esphome</code> 命令安装 ESPHome;使用 <code>ln -s /home/coolcall/.local/bin/esphome /usr/local/bin/esphome</code> 创建<del>软连接</del> ；使用 <code>sudo esphome dashboard config/</code> 运行。</li></ol><h2 id=\"esp8266-接入-esphome\"><a href=\"#esp8266-接入-esphome\">ESP8266 接入 ESPHome</a></h2><ol><li>在 ESPHome 的管理页面中（建议在 windows 系统下使用 Liunx IP 地址的 6052 端口号访问，虚拟机使用桥接模式），点击<code>NEW DEVICE</code> 添加新设备，输入<code>name</code> ，在选择<code>ESP8266</code> 并出现<code>Configuration created!</code>后，先选择<code>SKIP</code>，然后在页面右上角的<code>SECRETS</code>处配置网络并保存。</li><li>完成后打开<code>EDIT</code>并进行<code>INSTALL</code>，选择第四个，这里我选择使用 ESP8266Flasher 刷写下载的<code>.bin</code>（需要安装 CH341 驱动），当然你也可以选择使用 ESPHome 提供的 web 页面进行刷写。这里需要下载编译链，请保持良好的网络环境并等待一段时间。</li><li>刷写成功后，ESP8266 就可以连接到 ESPHome 了，页面将会显示固件上线，再次点击<code>EDIT</code>，在<code>captive_portal:</code>后添加以下代码：</li></ol><!-- HTML_TAG_START --><pre class=\"shiki material-default\" yaml=\"true\"><div class=\"language-id\">yaml</div><div class='code-container'><code><div class='line'>web_server:</div><div class='line'>  port: 80</div><div class='line'></div><div class='line'>switch:</div><div class='line'>  - platform: gpio</div><div class='line'>    pin: GPIO0</div><div class='line'>    name: \"书房灯\"</div><div class='line'>    id: relay2</div><div class='line'>    inverted: True</div><div class='line'>    </div><div class='line'>binary_sensor:</div><div class='line'>  - platform: gpio</div><div class='line'>    pin: GPIO2</div><div class='line'>    name: \"press_switch_lib1\"</div><div class='line'>    device_class: opening</div><div class='line'>    filters:</div><div class='line'>      - delayed_on_off: 100ms #消抖</div><div class='line'>    on_state:  #当这个二进制传感器状态改变的时候，触发 gpio0</div><div class='line'>      then:</div><div class='line'>        - switch.toggle: relay2</div></code></div></pre><!-- HTML_TAG_END --><p>再次<code>INSTALL</code>时即可选择第一个选项刷写。</p><h2 id=\"在-ha-中添加固件\"><a href=\"#在-ha-中添加固件\">在 HA 中添加固件</a></h2><ol><li>在 HA 的配置面板中选择设备与服务，在添加集成中搜索 ESPHome，主机地址需要填写上文中的<code>NAME</code>，在输入 key 后即可添加成功。（key 可以在刷写的<code>.yaml</code>文件中找到）</li></ol><h2 id=\"其他\"><a href=\"#其他\">其他</a></h2><p>WIFI 省电模式：</p><!-- HTML_TAG_START --><pre class=\"shiki material-default\" yaml=\"true\"><div class=\"language-id\">yaml</div><div class='code-container'><code><div class='line'>wifi:</div><div class='line'>  # ...</div><div class='line'>power_save_mode: light</div></code></div></pre><!-- HTML_TAG_END -->","date_published":"2023-01-13T00:00:00.000Z","date_modified":"2023-02-27T00:00:00.000Z","tags":["IoT"],"_indieweb":{"type":"article"}}]}